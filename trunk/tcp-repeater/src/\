#include "realserv.h"
#include "../include/nodetype.h"
#include "../include/message.h"

struct childnode*
init_childnode(){
    struct childnode *child = (struct childnode*)malloc(sizeof(struct childnode));
    if(child ==NULL){
        err_sys("malloc error");
    }
    child->links = 0;
    child->state = INITIAL_STATE;
    child->links =  0;
    child->tcp_threads = 2;
    child->lock = PTHREAD_MUTEX_INITIALIZER;
    return child;
}

void
read_realserv_config(struct childnode* node){
    char line[MAXLINE],key[MAXLINE],value[MAXLINE];
    FILE *fp;
    fp = Fopen("config/node.ini","r");
    while(Fgets(line,MAXLINE,fp)){
        if(feof(fp))
            break;
        if(line[0] =='#')
            continue;
        else if(line[0]=='\0' || line[0]=='\n' || line[0]==' ')
            continue;
        sscanf(line,"%s = %s\n",key,value);
        if(!strcmp(key,"father_ip")){
            node->father_ip = inet_addr(value);
        }else if(!strcmp(key,"max_links")){
            node->max_links = atoi(value);
        }else if(!strcmp(key,"node_type")){
            if(strcmp(value,"LB")!=0){
                err_quit("read configure file error!\n");
            }
        }
    } 
}

void*
send_heartbeat(void *arg){
    struct childnode *child = (struct childnode*)(arg);
    struct sockaddr_in serv;
    int n;
    serv.sin_family = AF_INET;
    serv.sin_port = htons(UDP_PORT);
    serv.sin_addr.s_addr = child->father_ip;
    int sockfd = Socket(AF_INET,SOCK_DGRAM,0);
    struct message msg ;
    msg.msgtype = UDP_HEARTBEAT;
    msg.child_id = child->id;
    msg.state = child->state;
    msg.info.links = child->links;
    while(1){
        if((n = sendto(sockfd,(void*)&msg,sizeof(msg),0,(struct sockaddr*)&serv,sizeof(serv))) != sizeof(struct message)){
            perror("send heartbeat error");
            continue;
        }
        sleep(HEARTBEAT_RATE);
    }
    return NULL;
}

void* 
send_activation_message(void *arg){
    int sockfd;
    struct sockaddr_in serv;
    struct childnode *child = (struct childnode*)arg;
    serv.sin_family = AF_INET;
    serv.sin_port = htons(TCP_PORT);
    serv.sin_addr.s_addr = child->father_ip;
    sockfd = Socket(AF_INET,SOCK_STREAM,0);
    
    struct message msg;
    msg.msgtype  = TCP_ACTIVATION;
    msg.child_id = 0;
    msg.state = child->state;
    Connect(sockfd,(struct sockaddr*)&serv,sizeof(serv));
    Send(sockfd,&msg,sizeof(msg),0);
    int n= Recv(sockfd,&msg,sizeof(msg),0);
    if(n != sizeof(msg))
        err_quit("receive activation ack message error");
    if(msg.msgtype ==TCP_ACTIVATION_ACK){
        child->id = msg.child_id;
        child->state = NORMAL_STATE;
    }
    printf("Get activation ack message from traffic server !\n");
    close(sockfd);
    return NULL;
}
/*****************process tcp message ***********************/

int tcp_childfd;
pthread_mutex_t tcp_childsock_lock = PTHREAD_MUTEX_INITIALIZER;

void 
recv_tcp_message(struct childnode *child,int connfd,in_addr_t srcaddr){
    char buf[PACKET_LEN];
    int len;
    struct message *msg;
    struct in_addr addr;
    pthread_t tid;
    addr.s_addr = srcaddr;
    printf("receive message from %s\n",inet_ntoa(addr));
    for(;;){
        len = Recv(connfd,(void*)buf,PACKET_LEN,0);
        if(len ==0){
            printf("the connection was closed by %s!\n",inet_ntoa(addr));
            break;
        }
        msg = (struct message*)buf;
        switch(msg->msgtype){
            case TCP_FAULT_QUERY:
                Pthread_create(&tid,NULL,&send_activation_message,(void*)child);
                break;
            case TCP_FTP:
                break;
            default:
                break;
        }
    }
    close(connfd);
}

void *
child_tcp_thread(void *arg){
    struct childnode *child = (struct childnode*)arg;
    int connfd;
    socklen_t clilen;
    struct sockaddr_in cliaddr;
    for(;;){
        Pthread_mutex_lock(&tcp_childsock_lock);
        connfd = Accept(tcp_childfd,(struct sockaddr*)&cliaddr,&clilen);
        Pthread_mutex_unlock(&tcp_childsock_lock);
        printf("the message was from %s\n",inet_ntoa(cliaddr.sin_addr));
        recv_tcp_message(child,connfd,cliaddr.sin_addr.s_addr);
    }
    return NULL;
}
void *
process_tcp_message(void *arg){
    struct childnode *child = (struct childnode*)arg;
    struct sockaddr_in serv;
    int i;
    pthread_t tid;
    bzero(&serv,sizeof(struct sockaddr_in));
    serv.sin_family = AF_INET;
    serv.sin_port = htons(TCP_PORT);
    serv.sin_addr.s_addr = htonl(INADDR_ANY);
    tcp_childfd = Socket(AF_INET,SOCK_STREAM,0);
    Bind(tcp_childfd,(struct sockaddr*)&serv,sizeof(struct sockaddr_in));
    Listen(tcp_childfd,LISTENQ);
    for(i=0;i<child->tcp_threads;i++){
        Pthread_create(&tid,NULL,&child_tcp_thread,(void*)child);
    }
    return NULL;    
}
void 
realserv_start(){
    pthread_t tid;
    struct childnode *child = init_childnode();
    read_realserv_config(child);
    send_activation_message(child);    
    if(child->state==NORMAL_STATE){
        Pthread_create(&tid,NULL,&send_heartbeat,(void*)child);
        Pthread_create(&tid,NULL,&process_tcp_message,(void *)child);
    }
    for(;;)
        pause();
}



